#import "./template.typ": *
#import "./theme.typ": *
#pagebreak()
= Implementation <Implementation>

As mentioned in @Introduction, we implemented both the `Rew` and the `ORew` algorithms in Lean 4 and compared the resulting constraints.

Our implementation aligns closely with the algorithms seen in @rewalgo, @subterm, @multifalgo, and @infersubp. To keep track of which side of a rewrite theorem needs to unify, we pass along a variable of type boolean for the direction mentioned in @PaperAlgo that we call `l2r`. This variable provides the context of which subterm of a rewrite theorem $rho : r space l space r$ must unify inside the unification function. The choice between $(<-)$ and $(->)$ is directed by the desired relation $r$ mentioned in @subterm. We also had to implement more logic compared to Coq's rewriting implementation for deeply nested rewrites of functions at the beginning of an application sequence as mentioned in @compcorrections.

It is a common use case to perform rewrites using existing theorems such as addition commutativity or `Nat.add_comm` ($forall n space m : NN, n + m = m + n$) or `Nat.right_distrib` ($forall n space m space k : NN, (n+m) dot k = n dot k + m dot k$). Both of those theorems are defined with universal quantifiers. During the execution of the algorithm for constraint generation, we are looking for unifications of the term $n + m$ for $rho := mono("Nat.add_comm")$ assuming a left-to-right rewrite. That means we have to go inside the $forall$-binder every time. As this information does not change during the execution, we wrapped the algorithm in a reader monad containing all relevant information about the theorem in the context. This is the carrier relation $=$, the left-hand side of $rho$, the right-hand side of $rho$, the proof $rho$, and the possible metavariables for unused binder variables. Those unused binder variables eventually become goals for the user to solve and will not be affected by the proof search.

The paper for generalised rewriting in type theory @sozeau:inria-00628904 that inspired the Coq implementation and the official Coq library for morphisms @coqmorphism mention many theorems that drastically simplify the constraints generated by the `Rew` or `ORew` constraint generation algorithms. Both sources also rely on typeclass search. This has two advantages in Coq. Firstly, the Haskell-inspired typeclass system @casteran:hal-00702455 keeps track of all instances defined for a typeclass and allows access to those when resolving a typeclass. This is a convenient approach for users to create new instances that directly influence the proof search.

For instance, one example mentioned in the paper @casteran:hal-00702455 defines a primitive version of sets where a set is just `Type` and `eqset`, the equivalence of sets is thus a relation over set `SET` $->$ `SET` $->$ `Prop` and union is a function `Set` $->$ `Set` $->$ `Set`. If we want to leverage some theorems about sets for rewriting, we generate proper constraints as part of the proof skeleton generation. By defining the typeclass instance $mono("instance union_proper" : mono("Proper") space (mono("eqset") ==> mono("eqset") ==> mono("eqset")) space mono("union"))$ anywhere in the code, we assure that this instance is leveraged when a fitting `Proper` constraint is being solved.

The other reason Coq uses its typecalass search for the algorithm is because it can be extended with arbitrary theorems and tactics. This is crucial as the type class instances mentioned in the paper are not sufficient for solving the generated problems. This is why Coq's documentation @coqmorphism also contains a few tactics that apply theorems in a very specific order to take a shortcut in the proof search. For instance, the tactic `reflexive_proxy_tac` checks if there is a free existential variable (metavariable in Coq) of type relation and if so, assigns any reflexive relation (provided by the `find_rewrite_relation` tactic) followed by a theorem that transforms a `ProperProxy` term into a `ReflexiveProxy` and eventually a `Reflexive` class.

Although the typeclass search in Lean is very efficient and tailored to ad-hoc polymorphism @selsam2020tabledtypeclassresolution, it does not currently support arbitrary extension by custom tactics and theorems. This is also not a planned feature because it would disrupt the performance predictability. For this reason, we decided to develop our own extensible proof search and translated most typeclass instances and tactics from Coq's morphism library @coqmorphism to Lean theorems and Meta-tactics.

While we used aesop @aesop initially in combination with the `Rew` algorithm to solve simple goals, we combined the optimisations in the constraint generation in `ORew` with a proof search that focuses on backtracking beyond the currently active goal. We store all registered theorems inside a discrimination tree @discrtree which can efficiently store arbitrary values (theorems in our case) using a Lean expression as the key. This allowed us to find theorems that can transform a given goal. In fact, Lean uses this data structure for its typeclass resolution as well @aesop.

With theorems stored efficiently, we solve the syntactic holes in the rewrite proof skeleton by a depth-first proof search where we apply the first theorem that matches the current goal and directly move forward with the updated goal. Only when we cannot apply any more theorems, we backtrack. When a goal gets closed, we proceed to the next goal. It may also happen that already solved goals are unsolved again because metavariables can be shared.
